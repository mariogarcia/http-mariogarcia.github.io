= Frege and QuickCheck: Properties
@marioggar
2016-05-18
:jbake-type: post
:jbake-status: draft
:jbake-tags: frege, testing
:idprefix:
:sources: ../../../../../../../sources/2016/05/qc-frege-02/src

After going through the main parts of property base testing with
__QuickCheck__ and __Frege__ now I'm focusing only in
**properties**. Lets recall what was a property in the context of
__QuickCheck__.

=== What is a property

A property is an executable specification meaning a function that
holds for a set of values using the program (function or set of
functions) you want to test.

=== Create a simple property

As a rule of thumb the easiest way of creating a property is to
create a function that returns a Bool. A function retuning a Bool
can be treated as a `Testable` value. Then use the `Testable` function
as argument of the `property` function, to get a `Property` value and
leave __QuickCheck__ to do the rest. In summary:

* Create a function that returns `Bool`
* Invoke `property` passing the previous function
* Invoke __QuickCheck__

Lets create a simple function. This function has certain properties:

* Should double the absolute value of the number passed as argument if
that number is greater than 0 and less or equals than 10
* Otherwise returns 0

NOTE: I'm using `frege-gradle-plugin` for these examples, actually I'm
executing `./gradlew fregeQuickCheck --t` which executes and waits
until the source code changes to launch the tests again. Very useful
while developing.

This is the specification we have to respect:

[source,haskell,numbered]
.Specification
----
include::{sources}/test/frege/qc/BasicsCheck.fr[tags=badImplementation,indent=0]
----

Lets try a first version of our function:

[source,haskell,numbered]
.Bad Implementation
----
include::{sources}/main/frege/qc/Basics.fr[tags=badImplementation,indent=0]
----

And now execute __QuickCheck__ to see if this first version holds:

[source,shell]
.Output
----
c.BasicsCheck.alwaysPositiveBadCheck: *** Failed!                                                                                                                                             (after 7 tests and 2 shrinks):
Falsifiable
-1
----

Error as expected. So just using a negative number as argument the
function won't hold. Ok, we should take the absolute number and then
multiply by two.

[source,haskell,numbered]
.Good Implementation
----
include::{sources}/main/frege/qc/Basics.fr[tags=goodImplementation,indent=0]
----

[source,haskell,numbered]
.Specification
----
include::{sources}/test/frege/qc/BasicsCheck.fr[tags=goodImplementation,indent=0]
----

[source,shell]
.Output
----
c.BasicsCheck.alwaysPositiveCheck: +++ OK, passed 100 tests
----

Perfect!! Ok this was a good warm up exercise, lets do something more
complex.

[sidebar]
.Testable
****
If you check the `property` function type in the **frege repl** you'll
notice that it receives a value of type `Testable` and returns a
`Property`. `Bool` defines an instance of `Testable`.

[source,shell]
.Checking property function type
----
frege> import Test.QuickCheck
...
frege> :t property
frege> Testable prop => prop -> Property
----

****

=== Combining properties

Sometimes our function should follow more than one property at the
same time. How can I apply both functions in a given specification?
In the following example we're pretending to be a small financial
institution that lends money.

So we have a `Loan`:

[source,haskell,numbered]
.Loan
----
include::{sources}/main/frege/qc/Combine.fr[tags=loandata,indent=0]
----

NOTE: This is an example, please don't use this data as reference for
any financial development :P

We need to build a function processing an incoming loan. At this point
we only know which are the properties to reject a loan. It will be
rejected:

* When it has a negative amount
* When it goes outside the company defined boundaries (min: 0, max:
  100000)

Lets define these properties:

[source,haskell]
.Reject negative
----
include::{sources}/test/frege/qc/CombineCheck.fr[tags=rejectNegative,indent=0]
----

[source,haskell]
.Reject max
----
include::{sources}/test/frege/qc/CombineCheck.fr[tags=rejectBeyondMax,indent=0]
----

Lets see how we've defined our function with these requirements in
mind:

[source,haskell,numbered]
.First implementation
----
include::{sources}/main/frege/qc/Combine.fr[tags=calculateRisk1,indent=0]
----

Basically only `NORMAL` and `RISKY` loans are within the boundaries
the rest are `REJECTED`.

Ok, lets see if the function holds for these two properties:

[source,haskell,numbered]
.Testing properties
----
include::{sources}/test/frege/qc/CombineCheck.fr[tags=checkNegativeOrMax,indent=0]
----

[source,shell]
.quickCheck result
----
c.CombineCheck.checkRejectNegative: +++ OK, passed 100 tests
...
c.CombineCheck.checkRejectBeyondMax: +++ OK, passed 100 tests
----

Nice but there is a new requirement:

**All loans without name will be rejected as well**

Easy right ?, first refactor our function: